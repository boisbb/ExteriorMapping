#version 450

#include "constants.glsl"
#include "utils.glsl"

layout (local_size_x=32, local_size_y=32, local_size_z=1) in;

layout(set=0, binding=0) uniform MainViewDataCompute {
    mat4 invView;
    mat4 invProj;
    vec2 res;
    vec2 viewsTotalRes;
    int viewCnt;
} ubo;

layout(std430, set=0, binding=1) readonly buffer ssbo {
    ViewDataEvalCompute objects[];
} cssbo;

layout(std430, set=0, binding=5) buffer ssbo1 {
    FrustumHit objects[];
} cssboHits;

layout(std430, set=0, binding=6) writeonly buffer ssbo2 {
    int objects[];
} cssboHitsCount;

void main()
{
    vec2 origPixId = gl_GlobalInvocationID.xy * vec2(INTERPOLATE_PIXELS_X, INTERPOLATE_PIXELS_Y);

    if (origPixId.x < ubo.res.x && origPixId.y < ubo.res.y)
    {
        int intersectCount = 0;

        vec2 pixCenter = origPixId + vec2(float(INTERPOLATE_PIXELS_X) / 2, float(INTERPOLATE_PIXELS_Y) / 2);
        
        int linearId = int((ubo.res.x * origPixId.y) + origPixId.x);
        int hitsStartId = 0;//linearId * 2 * MAX_HITS;

        vec2 uv = pixCenter / ubo.res;
        vec2 d = uv * 2.0 - 1.0;

        vec4 target = ubo.invProj * vec4(d.x, d.y, 1.f, 1.f);

        vec3 org = (ubo.invView * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
        vec3 dir = (ubo.invView * vec4(normalize(target.xyz), 0.f)).xyz;

        for (int i = 0; i < ubo.viewCnt; i++)
        {
            ViewDataEvalCompute currentView = cssbo.objects[i];

            float intersects[2];
            int foundIntersects = 0;

            for (int j = 0; j < 6; j++)
            {
                vec4 currentPlane = currentView.frustumPlanes[j];

                vec3 frustumNormal = currentPlane.xyz;
                float frustumDistance = currentPlane.w;

                if (abs(dot(frustumNormal, dir)) > 1e-6)
                {
                    float t = -(dot(frustumNormal, org) + frustumDistance) / dot(frustumNormal, dir);
                    vec3 intersect = org + t * dir;

                    intersects[foundIntersects] = t;
                    foundIntersects += int(isPointInFrustum(t, intersect, currentView.frustumPlanes, j) 
                        && foundIntersects < 2) * 1;
                }
            }

            int idIn = int(intersects[0] >= intersects[1]);
            int idOut = int(intersects[0] < intersects[1]);

            cssboHits.objects[hitsStartId + intersectCount].viewId = i;
            cssboHits.objects[hitsStartId + intersectCount].t = intersects[idIn];
            cssboHits.objects[hitsStartId + MAX_HITS + intersectCount].viewId = i;     
            cssboHits.objects[hitsStartId + MAX_HITS + intersectCount].t = intersects[idOut];

            intersectCount += int(foundIntersects == 2);
        }

        // insert sort the intersections

        for (int i = 1; i < intersectCount; i++)
        {
            // hits in
            FrustumHit keyIn = cssboHits.objects[hitsStartId + i];

            int j = i - 1;
            while (j >= 0 && cssboHits.objects[hitsStartId + j].t > keyIn.t)
            {
                cssboHits.objects[hitsStartId + j + 1] = cssboHits.objects[hitsStartId + j] ;
                j = j - 1;
            }

            cssboHits.objects[hitsStartId + j + 1] = keyIn;

            // hits out
            FrustumHit keyOut = cssboHits.objects[hitsStartId + MAX_HITS + i];

            j = i - 1;
            while (j >= 0 && cssboHits.objects[hitsStartId + MAX_HITS + j].t > keyOut.t)
            {
                cssboHits.objects[hitsStartId + MAX_HITS + j + 1] = cssboHits.objects[hitsStartId + MAX_HITS + j];
                j = j - 1;
            }

            cssboHits.objects[hitsStartId + MAX_HITS + j + 1] = keyOut;
        }

        cssboHitsCount.objects[linearId] = linearId * 2 * MAX_HITS;
    }
}