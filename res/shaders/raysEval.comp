#version 450

#define MAX_VIEWS 128
#define MAX_INTERVALS 32
#define MAX_HITS 128
#define RAY_PIX_SAMPLES 128
#define MIN_INTERVAL_VIEWS 4

// #define WRITE_DEBUG

struct ViewDataEvalCompute
{
    vec4 frustumPlanes[6];
    mat4 view;
    mat4 proj;
    vec4 resOffset;
};

struct ViewEvalDebugCompute {
    vec4 frustumPlanes[6];
    int numOfIntersections;
    int numOfFoundIntervals;
    vec2 viewRes;
    // vec2 t[32];
    // uint ids[128];
};

struct IntervalHit {
    vec2 t;
    uint idBits[4];
};

struct FrustumHit
{
    float t;
    int viewId;
};

layout(set=0, binding=0) uniform MainViewDataCompute {
    mat4 invView;
    mat4 invProj;
    vec2 res;
    vec2 viewsTotalRes;
    int viewCnt;
} ubo;

layout(std430, set=0, binding=1) readonly buffer ssbo {
    ViewDataEvalCompute objects[];
} cssbo;

layout(std430, set=0, binding=2) buffer ssbo1 {
    ViewEvalDebugCompute objects[];
} cssboDebug;

layout(set=0, binding=3) uniform sampler2D viewImagesSampler;

layout(set=0, binding=4) uniform writeonly image2D novelImageSampler;


// layout(set=0, binding=2) buffer hSsbo {
//     RayFrustumHitsDataCompute objects[];
// } hitssbo;

layout (local_size_x=16, local_size_y=16, local_size_z=1) in;

vec2 calculateMaskId(float id)
{
    int maskId = int(floor(id / 32));
    int innermaskId = int(id) - (maskId * 32);

    return vec2(maskId, innermaskId);
}

vec2 calculatePixId(vec3 t, mat4 view, mat4 proj, vec2 res, vec2 offset)
{
    vec4 ct = proj * view * vec4(t, 1.f);
    ct /= ct.w;

    return (((ct.xy + 1) / 2) * res) + offset;
}

void main()
{
    vec2 pixId = gl_GlobalInvocationID.xy;

    if (pixId.x < ubo.res.x && pixId.y < ubo.res.y)
    {
        FrustumHit frustumHitsIn[MAX_HITS];
        FrustumHit frustumHitsOut[MAX_HITS];

        int intersectCount = 0;

        vec2 pixCenter = pixId + 0.5;
        vec2 uv = pixCenter / ubo.res;

        vec2 d = uv * 2.0 - 1.0;

        vec4 org4f = ubo.invView * vec4(0.0, 0.0, 0.0, 1.0);
        vec4 target = ubo.invProj * vec4(d.x, d.y, 1.f, 1.f);
        vec4 dir4f = ubo.invView * vec4(normalize(target.xyz), 0.f);

        vec3 org = org4f.xyz;
        vec3 dir = dir4f.xyz;

        for (int i = 0; i < ubo.viewCnt; i++)
        {
            ViewDataEvalCompute currentView = cssbo.objects[i];

            float intersects[2];
            int foundIntersects = 0;

            for (int j = 0; j < 6; j++)
            {
                vec4 currentPlane = currentView.frustumPlanes[j];

                vec3 frustumNormal = currentPlane.xyz;
                float frustumDistance = currentPlane.w;

                if (abs(dot(frustumNormal, dir)) > 1e-6)
                {
                    float t = -(dot(frustumNormal, org) + frustumDistance) / dot(frustumNormal, dir);
                    vec3 intersect = org + t * dir;

                    bool valid = true;

                    if (t < 0)
                    {
                        valid = false;
                    }
                    else
                    {
                        for (int k = 0; k < 6; k++)
                        {
                            if (k != j)
                            {
                                vec4 checkPlane = currentView.frustumPlanes[k];

                                vec3 checkNormal = checkPlane.xyz;
                                float checkDistance = checkPlane.w;

                                if (dot(checkNormal, intersect) + checkDistance < 0.f)
                                {
                                    valid = false;
                                }
                            }
                        }
                    }

                    if (valid == true && foundIntersects < 2)
                    {
                        intersects[foundIntersects] = t;
                        foundIntersects++;
                    }
                }
            }

            if (foundIntersects == 2)
            {
                frustumHitsIn[intersectCount].viewId = i;
                frustumHitsOut[intersectCount].viewId = i;

                if (intersects[0] < intersects[1])
                {
                    frustumHitsIn[intersectCount].t = intersects[0];
                    frustumHitsOut[intersectCount].t = intersects[1];
                }
                else
                {
                    frustumHitsIn[intersectCount].t = intersects[1];
                    frustumHitsOut[intersectCount].t = intersects[0];
                }

                intersectCount++;
            }
        }

        // insert sort the intersections
        for (int i = 1; i < intersectCount; i++)
        {
            // hits in
            FrustumHit keyIn = frustumHitsIn[i];

            int j = i - 1;
            while (j >= 0 && frustumHitsIn[j].t > keyIn.t)
            {
                frustumHitsIn[j + 1] = frustumHitsIn[j];
                j = j - 1;
            }

            frustumHitsIn[j + 1] = keyIn;

            // hits out
            FrustumHit keyOut = frustumHitsOut[i];

            j = i - 1;
            while (j >= 0 && frustumHitsOut[j].t > keyOut.t)
            {
                frustumHitsOut[j + 1] = frustumHitsOut[j];
                j = j - 1;
            }

            frustumHitsOut[j + 1] = keyOut;
        }



        // 32 because 128 / 4 = 32 since we are looking for intervals
        // containing at least 4 cameras, then there are max 32 intervals
        IntervalHit intervals[MAX_INTERVALS];

        int currentlyInInterval = 0;
        uint cameraIndexMask[4];
        cameraIndexMask[0] = 0;
        cameraIndexMask[1] = 0;
        cameraIndexMask[2] = 0;
        cameraIndexMask[3] = 0;

        float currentStartT = 0;

        int foundIntervals = 0;
        int inId = 0;
        int outId = 0;
        for (int i = 0; i < intersectCount * 2; i++)
        {
            FrustumHit hitIn = frustumHitsIn[inId];
            FrustumHit hitOut = frustumHitsOut[outId];

            if (hitIn.t <= hitOut.t && inId < intersectCount)
            {
                // add into interval
                currentlyInInterval++;

                vec2 maskId = calculateMaskId(hitIn.viewId);
                int outer = int(maskId.x);
                int inner = int(maskId.y);

                cameraIndexMask[outer] = cameraIndexMask[outer] | (1 << inner);

                currentStartT = hitIn.t;

                inId++;
            }
            else
            {
                // remove from interval and possibly write interval
                if (currentlyInInterval >= MIN_INTERVAL_VIEWS)
                {
                    bool alreadyIn = false;
                    for (int j = 0; j < foundIntervals; j++)
                    {
                        IntervalHit current = intervals[j];

                        bool currentSame = true;
                        bool newSame = true;
                        for (int k = 0; k < 4; k++)
                        {
                            uint mask = current.idBits[k] & cameraIndexMask[k];

                            if (mask != current.idBits[k])
                                currentSame = false;
                            
                            if (mask != cameraIndexMask[k])
                                newSame = false;

                        }

                        if (currentSame && newSame)
                        {
                            alreadyIn = true;
                            break;
                        }
                        else if (currentSame)
                        {
                            intervals[j].t = vec2(currentStartT, hitOut.t);
                            intervals[j].idBits = cameraIndexMask;
                        }
                        else if (newSame)
                        {
                            alreadyIn = true;
                            break;
                        }
                    }

                    if (!alreadyIn)
                    {
                        intervals[foundIntervals].t = vec2(currentStartT, hitOut.t);
                        intervals[foundIntervals].idBits = cameraIndexMask;
                        foundIntervals++;
                    }
                }

                currentlyInInterval--;

                vec2 maskId = calculateMaskId(hitOut.viewId);
                int outer = int(maskId.x);
                int inner = int(maskId.y);

                cameraIndexMask[outer] = cameraIndexMask[outer] & (~(1 << inner));

                // cycle until we find a previous value in the interval
                for (int j = inId; j >= 0; j--)
                {
                    FrustumHit prevHitIn = frustumHitsIn[j];
                    
                    if (prevHitIn.t == currentStartT && prevHitIn.viewId != hitOut.viewId)
                    {
                        break;
                    }
                    else if (prevHitIn.t == currentStartT && prevHitIn.viewId == hitOut.viewId)
                    {
                        continue;
                    }
                    else
                    {
                        vec2 prevMaskId = calculateMaskId(prevHitIn.viewId);
                        int prevOuter = int(maskId.x);
                        int prevInner = int(maskId.y);

                        uint prevIdNum = (1 << prevInner);
                        uint check = cameraIndexMask[prevOuter] & prevIdNum;

                        if (check == prevIdNum)
                        {
                            // it is in the interval
                            currentStartT = prevHitIn.t;
                            break;
                        }
                    }
                }

                outId++;
            }
        }

        float dist = 20;
        vec4 avg = vec4(0);

        vec4 testColor = vec4(1);
        int chosenView = -1;

        for (int i = 0; i < 1; i++)
        {
            for (int j = 0; j < 15; j++)
            {
                ViewDataEvalCompute currentView = cssbo.objects[j];

                vec2 maskId = calculateMaskId(j);
                int outer = int(maskId.x);
                int inner = int(maskId.y);

                uint check = intervals[i].idBits[outer] & (1 << inner);

                if (check == (1 << inner))
                {
                    mat4 view = currentView.view;
                    mat4 proj = currentView.proj;
                    vec2 res = currentView.resOffset.xy;
                    vec2 offset = currentView.resOffset.zw;
                    
                    float sampleDist = (intervals[i].t.y - intervals[i].t.x) / RAY_PIX_SAMPLES;
                    float segmentStart = intervals[i].t.x;

                    vec4 localMin = vec4(2);
                    vec4 localMax = vec4(-1);

                    vec4 localAvg = vec4(0);

                    for (int k = 0; k < RAY_PIX_SAMPLES; k++)
                    {
                        vec3 p = org + dir * (segmentStart + k * sampleDist);
                        vec2 pixId = calculatePixId(p, view, proj, res, offset);
                        vec2 pixIdNorm = pixId / ubo.viewsTotalRes;

                        // todo: here normalize the pixId
                        vec4 pixVal = texture(viewImagesSampler, pixIdNorm);

                        localMin = min(localMin, pixVal);
                        localMax = max(localMax, pixVal);

                        localAvg += pixVal;
                    }

                    localAvg /= RAY_PIX_SAMPLES;

                    vec4 localVecDist = localMax - localMin;
                    float localDist = localVecDist.x + localVecDist.y + localVecDist.z + localVecDist.w;

                    if (localDist < dist)
                    {
                        dist = localDist;
                        // avg = localMin + localVecDist / 2;
                        avg = localAvg;//localMin + localVecDist / 2;
                        chosenView = j;
                    }

                    // if (localDist)
                    // dist = min(dist, localDist);

                }
            }
        }



        if (foundIntervals > 0)
        {

            // vec4 color;
            // if (chosenView == 0)
            //     color = vec4(0);
            // else if (chosenView == 1)
            //     color = vec4(1,0,0,1);
            // else if (chosenView == 2)
            //     color = vec4(0,1,0,1);
            // else if (chosenView == 3)
            //     color = vec4(0,0,1,1);
            //imageStore(novelImageSampler, ivec2(pixId), color);
            imageStore(novelImageSampler, ivec2(pixId), avg);
        }
        else
        {
            imageStore(novelImageSampler, ivec2(pixId), vec4(0, 0, 1, 1));
        }

        int linearRes = int((ubo.res.x * pixId.y) + pixId.x);

#ifdef WRITE_DEBUG
        cssboDebug.objects[linearRes].numOfIntersections = intersectCount;
        cssboDebug.objects[linearRes].numOfFoundIntervals = foundIntervals;
        cssboDebug.objects[linearRes].viewRes = min(vec2(0.2, 1.0), vec2(0.5, 0.8));

        // for (int j = 0; j < foundIntervals; j++)
        // {
        //     cssboDebug.objects[linearRes].t[j] = intervals[j].t;
// 
        //     for (int k = 0; k < 4; k++)
        //     {
        //         cssboDebug.objects[linearRes].ids[int(j * 4 + k)] = intervals[j].idBits[k];
        //     }
        // }
#endif
        
    }
}

// [0, 3], [1, 2]