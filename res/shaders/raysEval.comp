#version 450

struct ViewDataEvalCompute
{
    vec4 frustumPlanes[6];
};

// struct RayFrustumHitsDataCompute
// {
//     vec2 t;
//     vec2 id;
//     int planeId;
// };

layout(set=0, binding=0) uniform MainViewDataCompute {
    mat4 invView;
    mat4 invProj;
    vec2 res;
    int viewCnt;
} ubo;

layout(std430, set=0, binding=1) readonly buffer ssbo {
    ViewDataEvalCompute objects[];
} cssbo;

struct FrustumHit
{
    float t;
    int viewId;
    bool start;
};

// layout(set=0, binding=2) buffer hSsbo {
//     RayFrustumHitsDataCompute objects[];
// } hitssbo;

layout (local_size_x=16, local_size_y=16, local_size_z=1) in;

void main()
{
    vec2 pixId = gl_GlobalInvocationID.xy;

    FrustumHit frustumHits[512];

    if (pixId.x <= ubo.res.x && pixId.y <= ubo.res.y)
    {
        vec2 pixCenter = pixId + 0.5;
        vec2 uv = pixCenter / ubo.res;

        vec2 d = uv * 2.0 - 1.0;

        vec4 org4f = ubo.invView * vec4(0.0, 0.0, 0.0, 1.0);
        vec4 target = ubo.invProj * vec4(d.x, d.y, 1.f, 1.f);
        vec4 dir4f = ubo.invView * vec4(normalize(target.xyz), 0.f);

        vec3 org = org4f.xyz;
        vec3 dir = dir4f.xyz;

        int intersectCount = 0;
        for (int i = 0; i < ubo.viewCnt; i++)
        {
            ViewDataEvalCompute currentView = cssbo.objects[i];

            float intersects[2];
            int foundIntersects = 0;

            for (int j = 0; j < 6; j++)
            {
                vec4 currentPlane = currentView.frustumPlanes[j];

                vec3 frustumNormal = currentPlane.xyz;
                float frustumDistance = currentPlane.w;

                if (abs(dot(frustumNormal, dir)) > 1e-6)
                {
                    float t = -(dot(frustumNormal, org) + frustumDistance) / dot(frustumNormal, dir);
                    vec3 intersect = org + t * dir;

                    bool valid = true;

                    if (t < 0)
                    {
                        valid = false;
                    }
                    else
                    {
                        for (int k = 0; k < 6; k++)
                        {
                            if (k != j)
                            {
                                vec4 checkPlane = currentView.frustumPlanes[k];

                                vec3 checkNormal = checkPlane.xyz;
                                float checkDistance = checkPlane.w;

                                if (dot(checkNormal, intersect) + checkDistance < 0.f)
                                {
                                    valid = false;
                                }
                            }
                        }
                    }

                    if (valid == true && foundIntersects < 2)
                    {
                        intersects[foundIntersects] = t;
                        foundIntersects++;
                    }
                }
            }

            if (foundIntersects == 2)
            {
                frustumHits[intersectCount].viewId = i;
                frustumHits[intersectCount + 1].viewId = i;

                if (intersects[0] < intersects[1])
                {
                    frustumHits[intersectCount].t = intersects[0];
                    frustumHits[intersectCount].start = true;

                    intersectCount++;

                    frustumHits[intersectCount].t = intersects[1];
                    frustumHits[intersectCount].start = false;
                }
                else
                {
                    frustumHits[intersectCount].t = intersects[1];
                    frustumHits[intersectCount].start = true;

                    intersectCount++;

                    frustumHits[intersectCount].t = intersects[0];
                    frustumHits[intersectCount].start = false;
                }

                intersectCount++;
            }
        }
    }
}